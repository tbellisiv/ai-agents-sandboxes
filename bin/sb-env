#!/bin/bash

set -eu

# shellcheck disable=SC2034

SCRIPT_NAME=$(basename $0)    #equivalent to ${0##*/}
SCRIPT_DIR=$(dirname $0)
SCRIPT_VERSION=0.1

LIB_DIR=$SCRIPT_DIR/../lib

GETOPTIONS_LIB_PATH=$LIB_DIR/getoptions_lib

if [ ! -f "$GETOPTIONS_LIB_PATH" ]; then
    echo "$SCRIPT_NAME: Aborting- library '$GETOPTIONS_LIB_PATH' does not exist"
    exit -1
fi

. $GETOPTIONS_LIB_PATH

parser_definition() {

	setup   REST help:usage abbr:true -- "Usage: $SCRIPT_NAME [<command>] [<command-options>]"

	msg -- '' "${SCRIPT_NAME}: Commands for generating/viewing sandbox session configuration" ''

	msg -- 'Options:'

	disp    :usage  -h --help
	disp    SCRIPT_VERSION    --version

	msg         -- '' 'Commands:'
	cmd dump -- "Dumps session configuration"
}

parser_definition_dump() {
	setup   REST help:usage abbr:true -- "Usage: $SCRIPT_NAME profile <command> [<options>]"
	msg -- '' 'Dumps docker compose env' ''
	msg -- 'Options:'
	param   SESSION        -s    --session 
	disp    :usage         -h    --help
}

eval "$(getoptions parser_definition) exit 1"

if [ $# -gt 0 ]; then
	cmd=$1
	shift
	case $cmd in
		dump)
			eval "$(getoptions parser_definition_dump)"
			;;

		--) # no subcommand, arguments only
	esac
fi

# Source: https://unix.stackexchange.com/questions/293393/find-a-specific-file-in-the-nearest-ancestor-of-the-current-working-directory
findconfig() {
  # from: https://www.npmjs.com/package/find-config#algorithm
  # 1. If X/file.ext exists and is a regular file, return it. STOP
  # 2. If X has a parent directory, change X to parent. GO TO 1
  # 3. Return NULL.

  if [ -f "$1" ]; then
    printf '%s\n' "${PWD%/}/$1"
  elif [[ "$PWD" = / || $(basename $PWD) = ".sb" ]]; then
    false
  else
    # a subshell so that we don't affect the caller's $PWD
    (cd .. && findconfig "$1")
  fi
}

# Source: https://unix.stackexchange.com/questions/293393/find-a-specific-file-in-the-nearest-ancestor-of-the-current-working-directory
find_sb_dir() {
  # from: https://www.npmjs.com/package/find-config#algorithm
  # 1. If X/file.ext exists and is a regular file, return it. STOP
  # 2. If X has a parent directory, change X to parent. GO TO 1
  # 3. Return NULL.

  if [ -d ".sb" ]; then
    printf '%s\n' "${PWD%/}/$1"
  elif [[ "$PWD" = / || $(basename $PWD) = ".sb" ]]; then
    false
  else
    # a subshell so that we don't affect the caller's $PWD
    (cd .. && findconfig "$1")
  fi
}

# Compute the sandbox configuration. Logic:
#
#   1. Find SB_PROJECT_ROOT (i.e. the directory containing sb-project.env):
#      - If --project-root is specified on the command-line, use it.
#      - If $SB_PROJECT_ROOT is defined, use it.
#      - If the current directory is a descendant of a directory containing sb-project.env or contains sb-project.env as a child, use it. Set SB_PROJECT_ROOT to the directory path. Set SB_PROJECT_ID to the basename of the directory path.
#	   - If the current directory is named '.sb' or is a descendant of a directoty named '.sb', use. Otherwise, abort. Set SB_PROJECT_ROOT to the directory path. Set SB_PROJECT_ID to the basename of the directory path.
#
#  2. Compute SB_WORKSPACE_MAIN_ROOT:
#     - SB_WORKSPACE_MAIN_ROOT=$SB_PROJECT_ROOT/..
#
#   3. Source $SB_PROJECT_ROOT/sb-project.env if present
#
#   4. Determine SB_PROFILE_ID:
#      - If --profile is specified on the command-line, use it
#      - if the current directory contains a sb-profile.env or is an ancestor of a directory that contains profile.env, use it (or abort if not found). Set SB_PROFILE_ID to the basename of the directory path.
#
#   5. Compute the path to the profile directory (SB_PROFILE_ROOT):
#      - SB_PROFILE_ROOT=$SB_PROJECT_ROOT/profiles/${SB_PROFILE_ID}
#
#   . Determine SB_SANDBOX_ID:
#      - If --sandbox is specified on the command-line, use it
#      - If $SB_PROFILE_DEFAULT_SANDBOX_ID is defined, use it.
#      - if the current directory contains sb-sandbox.env or is an ancestor of directory that contains sandbox.env, read SB_SANDBOX_ID and use it, Otherwise abort.
#
#	4. Compute the path to the sandbox directory (SB_SANDBOX_ROOT):
#       - SB_SANDBOX_ROOT=$SB_PROFILE_ROOT/sandboxes/${SB_SANDBOX_ID}
#
#   5. Compute the aggregate configuration:
#       - Add SB_WORKSPACE_ROOT
#		- If SB_PPOJECT_ID is not present in $SB_PROJECT_ROOT/sb-project.env, add it
#       - Add $SB_PROJECT_ROOT/sb-project.env
#		- If SB_PROFILE_ID is not present in $SB_PROFILE_ROOT/sb-profile.env, add it
#       - Add $SB_PROFILE_ROOT/sb-profile.env
#		- If SB_SANDBOX_ID is not present in $SB_SANDBOX_ROOT/sb-sandbox.env, add it
#       - Add $SB_SANDBOX_ROOT/sb-sandbox.env
#       - Add $SB_SANDBOX_ROOT/sb-user.env
#       - Add $SB_SANDBOX_ROOT/secrets.env
#       - Add $SB_SANDBOX_ROOT/compose.env



# For now, assume we are running this from the sandbox directory

env=()

#Add top-level computed vars- SB_PROJECT_ROOT, SB_PROFILE_ROOT, SB_WORKSPACE_MAIN_ROOT
SB_PROJECT_ROOT=$(readlink -f ../../../..)
SB_PROFILE_ROOT=$(readlink -f ../../../default)
SB_PROFILE_ID=$(basename $SB_PROFILE_ROOT)
SB_WORKSPACE_MAIN_ROOT=$(readlink -f $SB_PROJECT_ROOT/..)
env+=("SB_PROJECT_ROOT=$SB_PROJECT_ROOT" "SB_PROFILE_ROOT=$SB_PROFILE_ROOT" "SB_PROFILE_ID=$SB_PROFILE_ID" "SB_WORKSPACE_MAIN_ROOT=$SB_WORKSPACE_MAIN_ROOT")

PROFILE_ENV_PATH=$SB_PROFILE_ROOT/sb-profile.env

ENV_FILES="$SB_PROJECT_ROOT/sb-project.env $PROFILE_ENV_PATH sb-sandbox.env sb-user.env"

eval "ENV_FILES_ARRAY=($ENV_FILES)"
lines=
for f in $ENV_FILES; do
	if [ -f "$f" ]; then
		mapfile -t lines < $f
		env+=("${lines[@]}")
	else
		echo "$SCRIPT_NAME: Warning- configuration file '$f' does not exist" >&2
	fi
done

#Add sandbox-level computed vars
SB_SANDBOX_ID=sb01
SB_SANDBOX_ROOT=$SB_PROFILE_ROOT/sandboxes/$SB_SANDBOX_ID
env+=("SB_SANDBOX_ROOT=$SB_SANDBOX_ROOT" "SB_SANDBOX_ID=$SB_SANDBOX_ID")

ENV_FILES="compose.env secrets.env"

eval "ENV_FILES_ARRAY=($ENV_FILES)"
lines=
for f in $ENV_FILES; do
	if [ -f "$f" ]; then
		mapfile -t lines < $f
		env+=("${lines[@]}")
	else
		echo "$SCRIPT_NAME: Warning- configuration file '$f' does not exist" >&2
	fi
done

printf "%s\n" "${env[@]}"
