#!/bin/bash

set -u

# shellcheck disable=SC2034

SCRIPT_NAME=$(basename $0)    #equivalent to ${0##*/}
SCRIPT_DIR=$(dirname $0)
SCRIPT_VERSION=0.1

LIB_DIR=$SCRIPT_DIR/../lib

GETOPTIONS_LIB_PATH=$LIB_DIR/getoptions_lib

if [ ! -f "$GETOPTIONS_LIB_PATH" ]; then
    echo "$SCRIPT_NAME: Aborting- library '$GETOPTIONS_LIB_PATH' does not exist"
    exit -1
fi

. $GETOPTIONS_LIB_PATH

parser_definition() {

	setup   REST help:usage abbr:true -- "Usage: $SCRIPT_NAME [<command>] [<command-options>]"

	msg -- '' "${SCRIPT_NAME}: Commands for generating/viewing sandbox session configuration" ''

	msg -- 'Options:'

	disp    :usage  -h --help
	disp    SCRIPT_VERSION    --version

	msg         -- '' 'Commands:'
	cmd dump -- "Dumps session configuration"
}

parser_definition_dump() {
	setup   REST help:usage abbr:true -- "Usage: $SCRIPT_NAME profile <command> [<options>]"
	msg -- '' 'Dumps docker compose env' ''
	msg -- 'Options:'
	param   SESSION        -s    --session 
	disp    :usage         -h    --help
}

eval "$(getoptions parser_definition) exit 1"

if [ $# -gt 0 ]; then
	cmd=$1
	shift
	case $cmd in
		dump)
			eval "$(getoptions parser_definition_dump)"
			;;

		--) # no subcommand, arguments only
	esac
fi

# Source: https://unix.stackexchange.com/questions/293393/find-a-specific-file-in-the-nearest-ancestor-of-the-current-working-directory
findconfig() {
  # from: https://www.npmjs.com/package/find-config#algorithm
  # 1. If X/file.ext exists and is a regular file, return it. STOP
  # 2. If X has a parent directory, change X to parent. GO TO 1
  # 3. Return NULL.

  if [ -f "$1" ]; then
    printf '%s\n' "${PWD%/}/$1"
  elif [[ "$PWD" = / || $(basename $PWD) = ".sb" ]]; then
    false
  else
    # a subshell so that we don't affect the caller's $PWD
    (cd .. && findconfig "$1")
  fi
}

# Source: https://unix.stackexchange.com/questions/293393/find-a-specific-file-in-the-nearest-ancestor-of-the-current-working-directory
find_dir() {
  # from: https://www.npmjs.com/package/find-config#algorithm
  # 1. If X/file.ext exists and is a regular file, return it. STOP
  # 2. If X has a parent directory, change X to parent. GO TO 1
  # 3. Return NULL.

  if [ -d ".sb" ]; then
    printf '%s\n' "${PWD%/}/$1"
  elif [[ "$PWD" = / || $(basename $PWD) = ".sb" ]]; then
    false
  else
    # a subshell so that we don't affect the caller's $PWD
    (cd .. && find_project_root "$1")
  fi
}

# Compute the sandbox configuration. Logic:
#
#   1. Find SB_PROJECT_ROOT (i.e. the directory containing sb-project.env):
#      - If '--project-root <dir>' is specified on the command-line, set SB_PROJECT_ROOT=<dir>
#      - If $SB_PROJECT_ROOT is defined in the environment, use it.
#      - If the current directory is a descendant of a directory containing sb-project.env or contains sb-project.env as a child, use it. Set SB_PROJECT_ROOT to the directory path. Set SB_PROJECT_ID to the basename of the directory path.
#	   - If the current directory is named '.sb' or is a descendant of a directory named '.sb', use it. Otherwise, abort. Set SB_PROJECT_ROOT to the directory path. Set SB_PROJECT_ID to the basename of the directory path.
#      - Otherwise, abort.
#
#	2. Source $SB_PROJECT_ROOT/sb-project.env if present
#
#   3. Determine SB_PROJECT_ID:
#      - If SB_PROJECT_ID is defined, use it, otherwise abort.
#
#	3. Compute SB_WORKSPACE_MAIN_ROOT:
#       - SB_WORKSPACE_MAIN_ROOT=$SB_PROJECT_ROOT/..
#
#	4. Determine SB_SANDBOX_ROOT:
#      - If '--sandbox <sandbox-id>' is specified on the command-line, compute it: SB_SANDBOX_ROOT=$SB_PROJECT_ROOT/sandboxes/<sandbox-id>
#      - If $SB_PROJECT_DEFAULT_SANDBOX_ID is defined in the environment, compute it: SB_SANDBOX_ROOT=$SB_PROJECT_ROOT/sandboxes/$SB_PROJECT_DEFAULT_SANDBOX_ID
#      - if the current directory contains sb-sandbox.env or is a descendant of a directory that contains sb-sandbox.env, set SB_SANDBOX_ROOT to the directory containing sb-sandbox.env
#      - Otherwise, abort.
#
#   4. Compute SB_SANDBOX_ID:
#       - SB_SANDBOX_ID=$(basename $SB_SANDBOX_ROOT)
#
#   5. Compute the aggregate configuration available to docker-compose.yaml:
#       - Add SB_WORKSPACE_MAIN_ROOT
#       - Add SB_PROJECT_ROOT
#       - Add $SB_PROJECT_ROOT/sb-project.env
#       - Add SB_PROJECT_ID
#       - Add SB_SANDBOX_ROOT
#       - Add $SB_SANDBOX_ROOT/sb-sandbox.env
#       - Add $SB_SANDBOX_ROOT/sb-login.env
#       - Add $SB_SANDBOX_ROOT/sb-compose.env
# Note: The files below are added to container environment but are not available to docker-compose.yaml:
#       - Add $SB_SANDBOX_ROOT/user.env
#       - Add $SB_SANDBOX_ROOT/user-secrets.env


# For now, assume we are running this from the sandbox directory

env=()

# Added project/workspace env
SB_PROJECT_ROOT=$(readlink -f ../../../.sb)
SB_WORKSPACE_MAIN_ROOT=$(readlink -f $SB_PROJECT_ROOT/..)
env+=("SB_PROJECT_ROOT=$SB_PROJECT_ROOT" "SB_WORKSPACE_MAIN_ROOT=$SB_WORKSPACE_MAIN_ROOT")
ENV_FILES="$SB_PROJECT_ROOT/sb-project.env"
eval "ENV_FILES_ARRAY=($ENV_FILES)"
lines=
for f in $ENV_FILES; do
	if [ -f "$f" ]; then
		mapfile -t lines < $f
		env+=("${lines[@]}")
	else
		echo "$SCRIPT_NAME: Warning- configuration file '$f' does not exist" >&2
	fi
done

SB_SANDBOX_ID=default
SB_SANDBOX_ROOT=$SB_PROJECT_ROOT/sandboxes/$SB_SANDBOX_ID
env+=("SB_SANDBOX_ROOT=$SB_SANDBOX_ROOT" "SB_SANDBOX_ID=$SB_SANDBOX_ID")

# Add compose-specific env
ENV_FILES="sb-sandbox.env sb-login.env sb-compose.env"

eval "ENV_FILES_ARRAY=($ENV_FILES)"
lines=
for f in $ENV_FILES; do
	if [ -f "$f" ]; then
		mapfile -t lines < $f
		env+=("${lines[@]}")
	else
		echo "$SCRIPT_NAME: Warning- configuration file '$f' does not exist" >&2
	fi
done

printf "%s\n" "${env[@]}"
